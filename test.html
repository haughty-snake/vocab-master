<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VocabMaster - ê°œë°œì í…ŒìŠ¤íŠ¸ í˜ì´ì§€</title>
    <style>
        :root {
            --primary: #4285f4;
            --danger: #ea4335;
            --warning: #fbbc05;
            --success: #34a853;
            --bg: #f5f5f5;
            --card-bg: #ffffff;
            --text: #333333;
            --text-secondary: #666666;
            --border: #e0e0e0;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            padding: 20px;
            max-width: 900px;
            margin: 0 auto;
        }

        header {
            background: var(--danger);
            color: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
        }

        header h1 {
            font-size: 1.5rem;
            margin-bottom: 8px;
        }

        header p {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .warning-banner {
            background: #fff3cd;
            border: 1px solid var(--warning);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 20px;
        }

        .warning-banner strong {
            color: #856404;
        }

        .section {
            background: var(--card-bg);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 16px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .section h2 {
            font-size: 1.1rem;
            margin-bottom: 16px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border);
        }

        .section h3 {
            font-size: 0.95rem;
            margin: 16px 0 8px;
            color: var(--text-secondary);
        }

        .btn-group {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 12px;
        }

        .btn {
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .btn:hover {
            opacity: 0.9;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-danger {
            background: var(--danger);
            color: white;
        }

        .btn-warning {
            background: var(--warning);
            color: #333;
        }

        .btn-success {
            background: var(--success);
            color: white;
        }

        .btn-outline {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text);
        }

        .btn-sm {
            padding: 6px 12px;
            font-size: 0.8rem;
        }

        .output {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 16px;
            border-radius: 6px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.85rem;
            max-height: 400px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-break: break-all;
        }

        .output.empty {
            color: #666;
            font-style: italic;
        }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-ok {
            background: var(--success);
        }

        .status-warning {
            background: var(--warning);
        }

        .status-error {
            background: var(--danger);
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 12px;
            margin-bottom: 16px;
        }

        .info-card {
            background: var(--bg);
            padding: 12px;
            border-radius: 6px;
        }

        .info-card label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            display: block;
            margin-bottom: 4px;
        }

        .info-card span {
            font-weight: 600;
        }

        .info-card .sub-info {
            font-size: 0.75rem;
            color: var(--text-secondary);
            font-weight: normal;
            display: block;
            margin-top: 4px;
        }

        .back-link {
            display: inline-block;
            margin-top: 20px;
            color: var(--primary);
            text-decoration: none;
        }

        .back-link:hover {
            text-decoration: underline;
        }

        .test-description {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 12px;
        }

        .storage-summary {
            display: flex;
            gap: 16px;
            padding: 16px;
            background: var(--bg);
            border-radius: 8px;
            margin-bottom: 16px;
        }

        .storage-summary .summary-item {
            flex: 1;
            text-align: center;
        }

        .storage-summary .summary-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary);
        }

        .storage-summary .summary-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .tabs {
            display: flex;
            gap: 4px;
            margin-bottom: 12px;
            border-bottom: 1px solid var(--border);
            padding-bottom: 8px;
        }

        .tab-btn {
            padding: 8px 16px;
            border: none;
            background: transparent;
            cursor: pointer;
            border-radius: 4px 4px 0 0;
            font-size: 0.85rem;
        }

        .tab-btn.active {
            background: var(--primary);
            color: white;
        }

        .format-badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 600;
            margin-left: 4px;
        }

        .format-json {
            background: #e3f2fd;
            color: #1565c0;
        }

        .format-lz {
            background: #e8f5e9;
            color: #2e7d32;
        }

        .compression-ratio {
            display: inline-block;
            padding: 2px 8px;
            background: var(--success);
            color: white;
            border-radius: 4px;
            font-size: 0.75rem;
            margin-left: 8px;
        }
    </style>
    <script>
        function goBack() {
            // í•­ìƒ location.replaceë¡œ ì´ë™ (popstate ì´ë²¤íŠ¸ ë°©ì§€)
            location.replace('index.html');
        }
    </script>
</head>
<body>
    <header>
        <h1>VocabMaster ë°ì´í„° í…ŒìŠ¤íŠ¸ í˜ì´ì§€</h1>
        <p>ê°œë°œì ì „ìš© - ë°ì´í„° ì†ìƒ, ë³µêµ¬, ì••ì¶• í…ŒìŠ¤íŠ¸</p>
    </header>

    <div class="warning-banner">
        <strong>ì£¼ì˜:</strong> ì´ í˜ì´ì§€ì˜ ê¸°ëŠ¥ë“¤ì€ ì‹¤ì œ ë°ì´í„°ë¥¼ ìˆ˜ì •í•˜ê±°ë‚˜ ì‚­ì œí•©ë‹ˆë‹¤.
        í…ŒìŠ¤íŠ¸ ì „ ë°˜ë“œì‹œ ë°±ì—…í•˜ì„¸ìš”!
    </div>

    <!-- ì €ì¥ì†Œ ì‚¬ìš©ëŸ‰ ìš”ì•½ -->
    <div class="section">
        <h2>ì €ì¥ì†Œ ì‚¬ìš©ëŸ‰</h2>
        <div class="storage-summary">
            <div class="summary-item">
                <div class="summary-value" id="total-json-size">-</div>
                <div class="summary-label">JSON í¬ê¸°</div>
            </div>
            <div class="summary-item">
                <div class="summary-value" id="total-stored-size">-</div>
                <div class="summary-label">ì‹¤ì œ ì €ì¥ í¬ê¸°</div>
            </div>
            <div class="summary-item">
                <div class="summary-value" id="compression-ratio">-</div>
                <div class="summary-label">ì••ì¶•ë¥ </div>
            </div>
            <div class="summary-item">
                <div class="summary-value" id="compression-status">-</div>
                <div class="summary-label">ì••ì¶• ì„¤ì •</div>
            </div>
        </div>
    </div>

    <!-- í˜„ì¬ ìƒíƒœ ì„¹ì…˜ -->
    <div class="section">
        <h2>í˜„ì¬ ì €ì¥ì†Œ ìƒíƒœ</h2>
        <div class="info-grid" id="storage-status">
            <div class="info-card">
                <label>Main Progress</label>
                <span id="status-progress">í™•ì¸ ì¤‘...</span>
                <span class="sub-info" id="status-progress-format"></span>
            </div>
            <div class="info-card">
                <label>Backup Progress</label>
                <span id="status-progress-backup">í™•ì¸ ì¤‘...</span>
                <span class="sub-info" id="status-progress-backup-format"></span>
            </div>
            <div class="info-card">
                <label>Main Stats</label>
                <span id="status-stats">í™•ì¸ ì¤‘...</span>
                <span class="sub-info" id="status-stats-format"></span>
            </div>
            <div class="info-card">
                <label>Backup Stats</label>
                <span id="status-stats-backup">í™•ì¸ ì¤‘...</span>
                <span class="sub-info" id="status-stats-backup-format"></span>
            </div>
            <div class="info-card">
                <label>Custom Categories</label>
                <span id="status-categories">í™•ì¸ ì¤‘...</span>
                <span class="sub-info" id="status-categories-format"></span>
            </div>
            <div class="info-card">
                <label>Backup Categories</label>
                <span id="status-categories-backup">í™•ì¸ ì¤‘...</span>
                <span class="sub-info" id="status-categories-backup-format"></span>
            </div>
            <div class="info-card">
                <label>Settings</label>
                <span id="status-settings">í™•ì¸ ì¤‘...</span>
                <span class="sub-info" id="status-settings-format"></span>
            </div>
            <div class="info-card">
                <label>Session Temp</label>
                <span id="status-temp">í™•ì¸ ì¤‘...</span>
            </div>
        </div>
        <div class="btn-group">
            <button class="btn btn-primary" onclick="refreshStatus()">ìƒíƒœ ìƒˆë¡œê³ ì¹¨</button>
        </div>
    </div>

    <!-- ë°ì´í„° ì¡°íšŒ ì„¹ì…˜ -->
    <div class="section">
        <h2>ë°ì´í„° ì¡°íšŒ</h2>
        <p class="test-description">ì €ì¥ëœ ë°ì´í„°ë¥¼ JSON ë˜ëŠ” ì›ë³¸(ì••ì¶•) í˜•íƒœë¡œ í™•ì¸í•©ë‹ˆë‹¤.</p>

        <div class="tabs">
            <button class="tab-btn active" id="tab-json" onclick="setViewMode('json')">JSON (íŒŒì‹±)</button>
            <button class="tab-btn" id="tab-raw" onclick="setViewMode('raw')">Raw (ì›ë³¸)</button>
            <button class="tab-btn" id="tab-both" onclick="setViewMode('both')">ë‘˜ ë‹¤</button>
        </div>

        <div class="btn-group">
            <button class="btn btn-outline" onclick="viewData('vocabmaster_progress')">Progress</button>
            <button class="btn btn-outline" onclick="viewData('vocabmaster_progress_backup')">Progress Backup</button>
            <button class="btn btn-outline" onclick="viewData('vocabmaster_stats')">Stats</button>
            <button class="btn btn-outline" onclick="viewData('vocabmaster_stats_backup')">Stats Backup</button>
            <button class="btn btn-outline" onclick="viewData('vocabmaster_settings')">Settings</button>
            <button class="btn btn-outline" onclick="viewData('vocabmaster_custom_categories')">Categories</button>
            <button class="btn btn-outline" onclick="viewData('vocabmaster_custom_categories_backup')">Categories Backup</button>
            <button class="btn btn-outline" onclick="viewSessionData()">Session Temp</button>
        </div>
        <div class="output empty" id="data-output">ë°ì´í„°ë¥¼ ì„ íƒí•˜ì„¸ìš”</div>
    </div>

    <!-- ì••ì¶• í…ŒìŠ¤íŠ¸ ì„¹ì…˜ -->
    <div class="section">
        <h2>ì••ì¶• í…ŒìŠ¤íŠ¸</h2>
        <p class="test-description">LZ-String ì••ì¶• ê¸°ëŠ¥ì„ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤.</p>

        <h3>ì••ì¶• ê¸°ëŠ¥ í…ŒìŠ¤íŠ¸</h3>
        <div class="btn-group">
            <button class="btn btn-primary" onclick="testCompression()">ì••ì¶•/í•´ì œ í…ŒìŠ¤íŠ¸</button>
            <button class="btn btn-primary" onclick="testAutoDetect()">ìë™ í˜•ì‹ ê°ì§€ í…ŒìŠ¤íŠ¸</button>
            <button class="btn btn-primary" onclick="testCompressionRatio()">ì••ì¶•ë¥  í…ŒìŠ¤íŠ¸</button>
        </div>

        <h3>ì••ì¶• ë§ˆì´ê·¸ë ˆì´ì…˜ (ì•ˆì „ ëª¨ë“œ)</h3>
        <div class="btn-group">
            <button class="btn btn-success" onclick="migrateToCompressed()">ì••ì¶• í˜•ì‹ìœ¼ë¡œ ë³€í™˜</button>
            <button class="btn btn-warning" onclick="migrateToJson()">JSON í˜•ì‹ìœ¼ë¡œ ë³€í™˜</button>
            <button class="btn btn-primary" onclick="testSafeMigrationRollback()">ë¡¤ë°± í…ŒìŠ¤íŠ¸</button>
        </div>
        <p class="test-description" style="margin-top: 8px; font-size: 0.8rem;">
            ì•ˆì „ ë©”ì»¤ë‹ˆì¦˜: ì„ì‹œ í‚¤ì— ì €ì¥ â†’ ê²€ì¦ â†’ ì„±ê³µ ì‹œë§Œ ì ìš© â†’ ì‹¤íŒ¨ ì‹œ ë¡¤ë°±
        </p>

        <div class="output empty" id="compression-output">í…ŒìŠ¤íŠ¸ ê²°ê³¼ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤</div>
    </div>

    <!-- ë°ì´í„° ì†ìƒ í…ŒìŠ¤íŠ¸ ì„¹ì…˜ -->
    <div class="section">
        <h2>ë°ì´í„° ì†ìƒ ì‹œë®¬ë ˆì´ì…˜</h2>
        <p class="test-description">ì˜ë„ì ìœ¼ë¡œ ë°ì´í„°ë¥¼ ì†ìƒì‹œì¼œ ë³µêµ¬ ë©”ì»¤ë‹ˆì¦˜ì„ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤.</p>

        <h3>Progress ë°ì´í„°</h3>
        <div class="btn-group">
            <button class="btn btn-danger" onclick="corruptData('vocabmaster_progress')">Main ì†ìƒ</button>
            <button class="btn btn-danger" onclick="corruptData('vocabmaster_progress_backup')">Backup ì†ìƒ</button>
            <button class="btn btn-danger" onclick="corruptBoth('progress')">ë‘˜ ë‹¤ ì†ìƒ</button>
        </div>

        <h3>Stats ë°ì´í„°</h3>
        <div class="btn-group">
            <button class="btn btn-danger" onclick="corruptData('vocabmaster_stats')">Main ì†ìƒ</button>
            <button class="btn btn-danger" onclick="corruptData('vocabmaster_stats_backup')">Backup ì†ìƒ</button>
            <button class="btn btn-danger" onclick="corruptBoth('stats')">ë‘˜ ë‹¤ ì†ìƒ</button>
        </div>

        <h3>Custom Categories</h3>
        <div class="btn-group">
            <button class="btn btn-danger" onclick="corruptData('vocabmaster_custom_categories')">Main ì†ìƒ</button>
            <button class="btn btn-danger" onclick="corruptData('vocabmaster_custom_categories_backup')">Backup ì†ìƒ</button>
            <button class="btn btn-danger" onclick="corruptBoth('categories')">ë‘˜ ë‹¤ ì†ìƒ</button>
        </div>

        <h3>ì „ì²´ ì†ìƒ</h3>
        <div class="btn-group">
            <button class="btn btn-danger" onclick="corruptAll()">ëª¨ë“  ë°ì´í„° ì†ìƒ</button>
        </div>
    </div>

    <!-- ë³µêµ¬ í…ŒìŠ¤íŠ¸ ì„¹ì…˜ -->
    <div class="section">
        <h2>ë³µêµ¬ í…ŒìŠ¤íŠ¸</h2>
        <p class="test-description">ì†ìƒëœ ë°ì´í„°ì— ëŒ€í•œ ë³µêµ¬ ë©”ì»¤ë‹ˆì¦˜ì„ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤.</p>
        <div class="btn-group">
            <button class="btn btn-success" onclick="testRecovery()">ë³µêµ¬ ì‹œë®¬ë ˆì´ì…˜</button>
            <button class="btn btn-warning" onclick="reloadApp()">ì•± ìƒˆë¡œê³ ì¹¨ (ì‹¤ì œ ë³µêµ¬)</button>
        </div>
        <div class="output empty" id="recovery-output">ë³µêµ¬ í…ŒìŠ¤íŠ¸ ê²°ê³¼ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤</div>
    </div>

    <!-- Write-Verify í…ŒìŠ¤íŠ¸ ì„¹ì…˜ -->
    <div class="section">
        <h2>Write-Verify íŒ¨í„´ í…ŒìŠ¤íŠ¸</h2>
        <p class="test-description">ì €ì¥ í›„ ê²€ì¦í•˜ëŠ” íŒ¨í„´ì´ ì •ìƒ ì‘ë™í•˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤.</p>
        <div class="btn-group">
            <button class="btn btn-primary" onclick="testWriteVerify()">ê¸°ë³¸ Write-Verify</button>
            <button class="btn btn-primary" onclick="testWriteVerifyCompressed()">ì••ì¶• Write-Verify</button>
        </div>
        <div class="output empty" id="write-verify-output">í…ŒìŠ¤íŠ¸ ê²°ê³¼ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤</div>
    </div>

    <!-- ë©€í‹°íƒ­ ë™ê¸°í™” í…ŒìŠ¤íŠ¸ -->
    <div class="section">
        <h2>ë©€í‹°íƒ­ ë™ê¸°í™” í…ŒìŠ¤íŠ¸</h2>
        <p class="test-description">ì—¬ëŸ¬ íƒ­ì—ì„œì˜ ë°ì´í„° ë™ê¸°í™”ë¥¼ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤.</p>
        <div class="btn-group">
            <button class="btn btn-primary" onclick="testReadModifyWrite()">Read-Modify-Write í…ŒìŠ¤íŠ¸</button>
            <button class="btn btn-primary" onclick="testProgressMerge()">Progress ë¨¸ì§€ í…ŒìŠ¤íŠ¸</button>
            <button class="btn btn-primary" onclick="simulateOtherTabChange()">ë‹¤ë¥¸ íƒ­ ë³€ê²½ ì‹œë®¬ë ˆì´ì…˜</button>
        </div>
        <div class="output empty" id="multitab-output">í…ŒìŠ¤íŠ¸ ê²°ê³¼ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤</div>
    </div>

    <!-- ëŒ€ëŸ‰ í…ŒìŠ¤íŠ¸ ë°ì´í„° -->
    <div class="section">
        <h2>ëŒ€ëŸ‰ ê°€ì ¸ì˜¤ê¸° í…ŒìŠ¤íŠ¸ ë°ì´í„°</h2>
        <p class="test-description">10,000ê°œ ë‹¨ì–´ ë²Œí¬ ê°€ì ¸ì˜¤ê¸° í…ŒìŠ¤íŠ¸ìš© íŒŒì¼ì„ ìƒì„±í•©ë‹ˆë‹¤. ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ì— ì‚¬ìš©í•˜ì„¸ìš”.</p>

        <div style="display: flex; gap: 16px; flex-wrap: wrap; margin-top: 16px;">
            <div style="flex: 1; min-width: 200px; padding: 16px; background: #f8f9fa; border-radius: 8px; border: 1px solid var(--border);">
                <div style="font-size: 2rem; margin-bottom: 8px;">ğŸ“„</div>
                <div style="font-weight: 600; margin-bottom: 4px;">JSON í…ŒìŠ¤íŠ¸ ë°ì´í„°</div>
                <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 12px;">10,000ê°œ ë‹¨ì–´ ìƒì„±</div>
                <button type="button" onclick="generateAndDownloadJSON(); return false;" class="btn btn-primary" style="width: 100%;">ìƒì„± ë° ë‹¤ìš´ë¡œë“œ</button>
            </div>
            <div style="flex: 1; min-width: 200px; padding: 16px; background: #f8f9fa; border-radius: 8px; border: 1px solid var(--border);">
                <div style="font-size: 2rem; margin-bottom: 8px;">ğŸ“Š</div>
                <div style="font-weight: 600; margin-bottom: 4px;">CSV í…ŒìŠ¤íŠ¸ ë°ì´í„°</div>
                <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 12px;">10,000ê°œ ë‹¨ì–´ ìƒì„±</div>
                <button type="button" onclick="generateAndDownloadCSV(); return false;" class="btn btn-primary" style="width: 100%;">ìƒì„± ë° ë‹¤ìš´ë¡œë“œ</button>
            </div>
        </div>

        <div style="margin-top: 16px; padding: 12px; background: #e3f2fd; border-radius: 6px; font-size: 0.85rem;">
            <strong>ğŸ’¡ ì‚¬ìš© ë°©ë²•:</strong>
            <ol style="margin: 8px 0 0 20px;">
                <li>ìœ„ ë²„íŠ¼ì„ í´ë¦­í•˜ì—¬ í…ŒìŠ¤íŠ¸ íŒŒì¼ ìƒì„±</li>
                <li>ì‚¬ìš©ì ì •ì˜ ì¹´í…Œê³ ë¦¬ ìƒì„±</li>
                <li>"íŒŒì¼ ê°€ì ¸ì˜¤ê¸°" í´ë¦­</li>
                <li>ë‹¤ìš´ë¡œë“œí•œ JSON ë˜ëŠ” CSV íŒŒì¼ ì„ íƒ</li>
            </ol>
        </div>
    </div>

    <!-- ë°ì´í„° ì´ˆê¸°í™” ì„¹ì…˜ -->
    <div class="section">
        <h2>ë°ì´í„° ì´ˆê¸°í™”</h2>
        <p class="test-description">ì €ì¥ëœ ë°ì´í„°ë¥¼ ì‚­ì œí•©ë‹ˆë‹¤. ì‹ ì¤‘í•˜ê²Œ ì‚¬ìš©í•˜ì„¸ìš”!</p>
        <div class="btn-group">
            <button class="btn btn-warning" onclick="clearBackups()">ë°±ì—…ë§Œ ì‚­ì œ</button>
            <button class="btn btn-warning" onclick="clearTemp()">Session Temp ì‚­ì œ</button>
            <button class="btn btn-danger" onclick="clearAllData()">ëª¨ë“  ë°ì´í„° ì‚­ì œ</button>
        </div>
    </div>

    <a href="javascript:void(0)" onclick="goBack()" class="back-link">â† VocabMasterë¡œ ëŒì•„ê°€ê¸°</a>

    <script src="js/lz-string.min.js"></script>
    <script>
        // ì €ì¥ì†Œ í‚¤ ì •ì˜
        const KEYS = {
            PROGRESS: 'vocabmaster_progress',
            PROGRESS_BACKUP: 'vocabmaster_progress_backup',
            STATS: 'vocabmaster_stats',
            STATS_BACKUP: 'vocabmaster_stats_backup',
            CUSTOM_CATEGORIES: 'vocabmaster_custom_categories',
            CUSTOM_CATEGORIES_BACKUP: 'vocabmaster_custom_categories_backup',
            SETTINGS: 'vocabmaster_settings',
            TEMP: 'vocabmaster_temp'
        };

        let currentViewMode = 'json';

        // í˜ì´ì§€ ë¡œë“œ ì‹œ ìƒíƒœ í™•ì¸
        document.addEventListener('DOMContentLoaded', () => {
            refreshStatus();
            updateStorageSummary();
        });

        // ==================== ì••ì¶• ê´€ë ¨ í•¨ìˆ˜ ====================

        function compress(data) {
            if (typeof LZString === 'undefined') return JSON.stringify(data);
            const json = JSON.stringify(data);
            return 'LZ:' + LZString.compressToUTF16(json);
        }

        function decompress(raw) {
            if (!raw) return null;
            if (raw.startsWith('LZ:')) {
                if (typeof LZString === 'undefined') return null;
                const compressed = raw.substring(3);
                const json = LZString.decompressFromUTF16(compressed);
                return json ? JSON.parse(json) : null;
            }
            if (raw.startsWith('{') || raw.startsWith('[')) {
                return JSON.parse(raw);
            }
            return null;
        }

        function detectFormat(raw) {
            if (!raw) return 'empty';
            if (raw.startsWith('LZ:')) return 'lz-string';
            if (raw.startsWith('{') || raw.startsWith('[')) return 'json';
            return 'unknown';
        }

        // ==================== ì €ì¥ì†Œ ìš”ì•½ ====================

        function updateStorageSummary() {
            let totalJsonSize = 0;
            let totalStoredSize = 0;

            const keys = [
                KEYS.PROGRESS, KEYS.PROGRESS_BACKUP,
                KEYS.STATS, KEYS.STATS_BACKUP,
                KEYS.CUSTOM_CATEGORIES, KEYS.CUSTOM_CATEGORIES_BACKUP
            ];

            keys.forEach(key => {
                const raw = localStorage.getItem(key);
                if (!raw) return;

                totalStoredSize += raw.length * 2; // UTF-16

                try {
                    const data = decompress(raw);
                    if (data) {
                        const jsonStr = JSON.stringify(data);
                        totalJsonSize += jsonStr.length * 2;
                    }
                } catch (e) {}
            });

            const jsonSizeKB = (totalJsonSize / 1024).toFixed(1);
            const storedSizeKB = (totalStoredSize / 1024).toFixed(1);
            const ratio = totalJsonSize > 0
                ? Math.round((1 - totalStoredSize / totalJsonSize) * 100)
                : 0;

            document.getElementById('total-json-size').textContent = jsonSizeKB + 'KB';
            document.getElementById('total-stored-size').textContent = storedSizeKB + 'KB';
            document.getElementById('compression-ratio').textContent = ratio > 0 ? ratio + '%' : '-';

            // ì••ì¶• ì„¤ì • ìƒíƒœ
            try {
                const settingsRaw = localStorage.getItem(KEYS.SETTINGS);
                if (settingsRaw) {
                    const settings = JSON.parse(settingsRaw);
                    document.getElementById('compression-status').textContent =
                        settings.compression?.enabled ? 'ON' : 'OFF';
                } else {
                    document.getElementById('compression-status').textContent = 'OFF';
                }
            } catch (e) {
                document.getElementById('compression-status').textContent = '-';
            }
        }

        // ==================== ìƒíƒœ í™•ì¸ ====================

        function refreshStatus() {
            checkStatus('status-progress', 'status-progress-format', KEYS.PROGRESS);
            checkStatus('status-progress-backup', 'status-progress-backup-format', KEYS.PROGRESS_BACKUP);
            checkStatus('status-stats', 'status-stats-format', KEYS.STATS);
            checkStatus('status-stats-backup', 'status-stats-backup-format', KEYS.STATS_BACKUP);
            checkStatus('status-categories', 'status-categories-format', KEYS.CUSTOM_CATEGORIES);
            checkStatus('status-categories-backup', 'status-categories-backup-format', KEYS.CUSTOM_CATEGORIES_BACKUP);
            checkStatus('status-settings', 'status-settings-format', KEYS.SETTINGS);
            checkSessionStatus();
            updateStorageSummary();
        }

        function checkStatus(elementId, formatId, key) {
            const el = document.getElementById(elementId);
            const formatEl = document.getElementById(formatId);
            const raw = localStorage.getItem(key);

            if (!raw) {
                el.innerHTML = '<span class="status-indicator status-warning"></span>ì—†ìŒ';
                if (formatEl) formatEl.innerHTML = '';
                return;
            }

            const format = detectFormat(raw);
            const formatBadge = format === 'lz-string'
                ? '<span class="format-badge format-lz">LZ</span>'
                : format === 'json'
                    ? '<span class="format-badge format-json">JSON</span>'
                    : '';

            try {
                const data = decompress(raw);
                if (data) {
                    const storedSize = raw.length * 2;
                    const jsonSize = JSON.stringify(data).length * 2;
                    const storedSizeStr = storedSize > 1024 ? `${(storedSize/1024).toFixed(1)}KB` : `${storedSize}B`;
                    const jsonSizeStr = jsonSize > 1024 ? `${(jsonSize/1024).toFixed(1)}KB` : `${jsonSize}B`;

                    el.innerHTML = `<span class="status-indicator status-ok"></span>ì •ìƒ (${storedSizeStr})`;
                    if (formatEl) {
                        formatEl.innerHTML = formatBadge + ` JSON: ${jsonSizeStr}`;
                    }
                } else {
                    throw new Error('Decompress failed');
                }
            } catch (e) {
                el.innerHTML = `<span class="status-indicator status-error"></span>ì†ìƒë¨`;
                if (formatEl) formatEl.innerHTML = formatBadge;
            }
        }

        function checkSessionStatus() {
            const el = document.getElementById('status-temp');
            const raw = sessionStorage.getItem(KEYS.TEMP);

            if (!raw) {
                el.innerHTML = '<span class="status-indicator status-warning"></span>ì—†ìŒ';
                return;
            }

            try {
                JSON.parse(raw);
                el.innerHTML = '<span class="status-indicator status-ok"></span>ì •ìƒ';
            } catch (e) {
                el.innerHTML = '<span class="status-indicator status-error"></span>ì†ìƒë¨';
            }
        }

        // ==================== ë°ì´í„° ì¡°íšŒ ====================

        function setViewMode(mode) {
            currentViewMode = mode;
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById('tab-' + mode).classList.add('active');
        }

        function viewData(key) {
            const output = document.getElementById('data-output');
            const raw = localStorage.getItem(key);

            if (!raw) {
                output.textContent = `[${key}] ë°ì´í„° ì—†ìŒ`;
                output.classList.add('empty');
                return;
            }

            const format = detectFormat(raw);
            let result = `[${key}]\ní˜•ì‹: ${format.toUpperCase()}\nì €ì¥ í¬ê¸°: ${(raw.length * 2 / 1024).toFixed(2)}KB\n`;
            result += 'â”€'.repeat(50) + '\n\n';

            if (currentViewMode === 'raw' || currentViewMode === 'both') {
                result += '=== RAW ë°ì´í„° ===\n';
                result += raw.length > 1000 ? raw.substring(0, 1000) + '...\n(truncated)' : raw;
                result += '\n\n';
            }

            if (currentViewMode === 'json' || currentViewMode === 'both') {
                result += '=== JSON ë°ì´í„° ===\n';
                try {
                    const data = decompress(raw);
                    if (data) {
                        const jsonStr = JSON.stringify(data, null, 2);
                        result += jsonStr.length > 5000 ? jsonStr.substring(0, 5000) + '\n...(truncated)' : jsonStr;
                        result += `\n\nJSON í¬ê¸°: ${(JSON.stringify(data).length * 2 / 1024).toFixed(2)}KB`;
                    } else {
                        result += 'íŒŒì‹± ì‹¤íŒ¨';
                    }
                } catch (e) {
                    result += 'íŒŒì‹± ì‹¤íŒ¨: ' + e.message;
                }
            }

            output.textContent = result;
            output.classList.remove('empty');
        }

        function viewSessionData() {
            const output = document.getElementById('data-output');
            const raw = sessionStorage.getItem(KEYS.TEMP);

            if (!raw) {
                output.textContent = '[Session Temp] ë°ì´í„° ì—†ìŒ';
                output.classList.add('empty');
                return;
            }

            try {
                const data = JSON.parse(raw);
                output.textContent = '[Session Temp]\n' + JSON.stringify(data, null, 2);
                output.classList.remove('empty');
            } catch (e) {
                output.textContent = `[Session Temp] íŒŒì‹± ì‹¤íŒ¨\nRaw: ${raw}`;
                output.classList.remove('empty');
            }
        }

        // ==================== ì••ì¶• í…ŒìŠ¤íŠ¸ ====================

        function testCompression() {
            const output = document.getElementById('compression-output');
            const results = [];

            results.push('=== LZ-String ì••ì¶•/í•´ì œ í…ŒìŠ¤íŠ¸ ===\n');

            const testData = {
                word1: 'memorized',
                word2: 'learning',
                word3: 'new',
                timestamp: Date.now()
            };

            // ì••ì¶•
            results.push('1. ì›ë³¸ ë°ì´í„°:');
            results.push('   ' + JSON.stringify(testData));

            const compressed = compress(testData);
            results.push('\n2. ì••ì¶• ê²°ê³¼:');
            results.push('   ' + compressed.substring(0, 50) + '...');
            results.push('   ì ‘ë‘ì‚¬: ' + (compressed.startsWith('LZ:') ? 'LZ: (ì •ìƒ)' : 'ì˜¤ë¥˜'));

            // í•´ì œ
            const decompressed = decompress(compressed);
            results.push('\n3. í•´ì œ ê²°ê³¼:');
            results.push('   ' + JSON.stringify(decompressed));

            // ê²€ì¦
            const isValid = JSON.stringify(testData) === JSON.stringify(decompressed);
            results.push('\n4. ê²€ì¦:');
            results.push('   ' + (isValid ? 'âœ… ì„±ê³µ - ë°ì´í„° ë¬´ê²°ì„± í™•ì¸' : 'âŒ ì‹¤íŒ¨ - ë°ì´í„° ë¶ˆì¼ì¹˜'));

            // í¬ê¸° ë¹„êµ
            const jsonSize = JSON.stringify(testData).length * 2;
            const compressedSize = compressed.length * 2;
            results.push('\n5. í¬ê¸° ë¹„êµ:');
            results.push(`   JSON: ${jsonSize}B, ì••ì¶•: ${compressedSize}B`);

            output.textContent = results.join('\n');
            output.classList.remove('empty');
        }

        function testAutoDetect() {
            const output = document.getElementById('compression-output');
            const results = [];

            results.push('=== ìë™ í˜•ì‹ ê°ì§€ í…ŒìŠ¤íŠ¸ ===\n');

            const testData = { test: 'data', value: 123 };

            // JSON í˜•ì‹
            const jsonStr = JSON.stringify(testData);
            results.push('1. JSON í˜•ì‹:');
            results.push('   ì…ë ¥: ' + jsonStr.substring(0, 30) + '...');
            results.push('   ê°ì§€: ' + detectFormat(jsonStr));
            results.push('   í•´ì œ: ' + (decompress(jsonStr) ? 'âœ… ì„±ê³µ' : 'âŒ ì‹¤íŒ¨'));

            // LZ-String í˜•ì‹
            const lzStr = compress(testData);
            results.push('\n2. LZ-String í˜•ì‹:');
            results.push('   ì…ë ¥: ' + lzStr.substring(0, 30) + '...');
            results.push('   ê°ì§€: ' + detectFormat(lzStr));
            results.push('   í•´ì œ: ' + (decompress(lzStr) ? 'âœ… ì„±ê³µ' : 'âŒ ì‹¤íŒ¨'));

            // ì†ìƒëœ ë°ì´í„°
            const corrupted = '{invalid json';
            results.push('\n3. ì†ìƒëœ ë°ì´í„°:');
            results.push('   ì…ë ¥: ' + corrupted);
            results.push('   ê°ì§€: ' + detectFormat(corrupted));
            try {
                decompress(corrupted);
                results.push('   í•´ì œ: âŒ ì˜ˆì™¸ ë¯¸ë°œìƒ');
            } catch (e) {
                results.push('   í•´ì œ: âœ… ì˜ˆì™¸ ë°œìƒ (ì •ìƒ)');
            }

            output.textContent = results.join('\n');
            output.classList.remove('empty');
        }

        function testCompressionRatio() {
            const output = document.getElementById('compression-output');
            const results = [];

            results.push('=== ì••ì¶•ë¥  í…ŒìŠ¤íŠ¸ ===\n');

            // ë‹¤ì–‘í•œ í¬ê¸°ì˜ í…ŒìŠ¤íŠ¸ ë°ì´í„°
            const sizes = [100, 500, 1000, 2000];

            sizes.forEach(size => {
                const data = {};
                for (let i = 0; i < size; i++) {
                    data[`word_${i}`] = i % 3 === 0 ? 'memorized' : i % 3 === 1 ? 'learning' : 'new';
                }

                const jsonStr = JSON.stringify(data);
                const compressed = compress(data);

                const jsonSize = jsonStr.length * 2;
                const compressedSize = compressed.length * 2;
                const ratio = Math.round((1 - compressedSize / jsonSize) * 100);

                results.push(`${size}ê°œ ë‹¨ì–´:`);
                results.push(`  JSON: ${(jsonSize/1024).toFixed(1)}KB â†’ ì••ì¶•: ${(compressedSize/1024).toFixed(1)}KB (${ratio}% ì ˆê°)`);
            });

            results.push('\nê²°ë¡ : ë°˜ë³µ íŒ¨í„´ì´ ë§ì€ ë°ì´í„°ì—ì„œ 50~90% ì••ì¶•ë¥  ë‹¬ì„±');

            output.textContent = results.join('\n');
            output.classList.remove('empty');
        }

        // ì•ˆì „í•œ ë§ˆì´ê·¸ë ˆì´ì…˜ (ì„ì‹œ í‚¤ ì‚¬ìš© + ê²€ì¦ + ë¡¤ë°±)
        async function safeMigrate(enableCompression) {
            const output = document.getElementById('compression-output');
            const results = [];
            const actionName = enableCompression ? 'ì••ì¶•' : 'JSON ë³€í™˜';

            results.push(`=== ì•ˆì „í•œ ${actionName} ë§ˆì´ê·¸ë ˆì´ì…˜ ===\n`);

            const keysToMigrate = [
                { main: KEYS.PROGRESS, backup: KEYS.PROGRESS_BACKUP, name: 'Progress' },
                { main: KEYS.STATS, backup: KEYS.STATS_BACKUP, name: 'Stats' },
                { main: KEYS.CUSTOM_CATEGORIES, backup: KEYS.CUSTOM_CATEGORIES_BACKUP, name: 'Categories' }
            ];

            const TEMP_SUFFIX = '_migration_temp';
            let allSuccess = true;

            for (const { main, backup, name } of keysToMigrate) {
                results.push(`\n[${name}]`);
                const originalRaw = localStorage.getItem(main);

                if (!originalRaw) {
                    results.push('  â†’ ë°ì´í„° ì—†ìŒ, ê±´ë„ˆëœ€');
                    continue;
                }

                const isCompressed = originalRaw.startsWith('LZ:');
                if (enableCompression === isCompressed) {
                    results.push(`  â†’ ì´ë¯¸ ${enableCompression ? 'ì••ì¶•' : 'JSON'} í˜•ì‹, ê±´ë„ˆëœ€`);
                    continue;
                }

                // 1ë‹¨ê³„: ì›ë³¸ ë°ì´í„° í•´ì œ
                const data = decompress(originalRaw);
                if (!data) {
                    results.push('  â†’ âŒ ì›ë³¸ ë°ì´í„° íŒŒì‹± ì‹¤íŒ¨');
                    allSuccess = false;
                    continue;
                }
                results.push('  1. ì›ë³¸ ë°ì´í„° íŒŒì‹± âœ…');

                // 2ë‹¨ê³„: ìƒˆ í˜•ì‹ìœ¼ë¡œ ì§ë ¬í™”
                const newSerialized = enableCompression ? compress(data) : JSON.stringify(data);
                results.push(`  2. ${actionName} ì™„ë£Œ (${(newSerialized.length * 2 / 1024).toFixed(1)}KB)`);

                // 3ë‹¨ê³„: ì„ì‹œ í‚¤ì— ì €ì¥ (ì›ë³¸ ë³´ì¡´)
                const tempKey = main + TEMP_SUFFIX;
                const tempBackupKey = backup + TEMP_SUFFIX;

                try {
                    localStorage.setItem(tempKey, newSerialized);
                    localStorage.setItem(tempBackupKey, newSerialized);
                    results.push('  3. ì„ì‹œ í‚¤ì— ì €ì¥ âœ…');
                } catch (e) {
                    results.push(`  3. âŒ ì„ì‹œ ì €ì¥ ì‹¤íŒ¨ (ìš©ëŸ‰ ë¶€ì¡±?): ${e.message}`);
                    localStorage.removeItem(tempKey);
                    localStorage.removeItem(tempBackupKey);
                    allSuccess = false;
                    continue;
                }

                // 4ë‹¨ê³„: ì„ì‹œ ë°ì´í„° ê²€ì¦
                const verifyRaw = localStorage.getItem(tempKey);
                const verifyData = decompress(verifyRaw);

                if (!verifyData || JSON.stringify(data) !== JSON.stringify(verifyData)) {
                    results.push('  4. âŒ ë°ì´í„° ê²€ì¦ ì‹¤íŒ¨ - ë¡¤ë°±');
                    localStorage.removeItem(tempKey);
                    localStorage.removeItem(tempBackupKey);
                    allSuccess = false;
                    continue;
                }
                results.push('  4. ë°ì´í„° ê²€ì¦ âœ…');

                // 5ë‹¨ê³„: ë©”ì¸ í‚¤ì— ì ìš©
                try {
                    localStorage.setItem(main, newSerialized);
                    localStorage.setItem(backup, newSerialized);
                    results.push('  5. ë©”ì¸ í‚¤ì— ì ìš© âœ…');
                } catch (e) {
                    // ì ìš© ì‹¤íŒ¨ - ì›ë³¸ ë³µêµ¬
                    localStorage.setItem(main, originalRaw);
                    results.push(`  5. âŒ ì ìš© ì‹¤íŒ¨, ì›ë³¸ ë³µêµ¬`);
                    allSuccess = false;
                }

                // 6ë‹¨ê³„: ì„ì‹œ ë°ì´í„° ì‚­ì œ
                localStorage.removeItem(tempKey);
                localStorage.removeItem(tempBackupKey);
                results.push('  6. ì„ì‹œ ë°ì´í„° ì‚­ì œ âœ…');
            }

            results.push('\n' + 'â”€'.repeat(50));
            results.push(allSuccess ? `\nâœ… ${actionName} ë§ˆì´ê·¸ë ˆì´ì…˜ ì™„ë£Œ!` : `\nâš ï¸ ì¼ë¶€ ë°ì´í„° ${actionName} ì‹¤íŒ¨`);

            output.textContent = results.join('\n');
            output.classList.remove('empty');
            refreshStatus();
        }

        function migrateToCompressed() {
            if (!confirm('ëª¨ë“  ë°ì´í„°ë¥¼ ì••ì¶• í˜•ì‹ìœ¼ë¡œ ë³€í™˜í•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\nì•ˆì „ ë©”ì»¤ë‹ˆì¦˜:\n- ì›ë³¸ ë°ì´í„° ë³´ì¡´\n- ê²€ì¦ í›„ ì ìš©\n- ì‹¤íŒ¨ ì‹œ ìë™ ë¡¤ë°±')) return;
            safeMigrate(true);
        }

        function migrateToJson() {
            if (!confirm('ëª¨ë“  ë°ì´í„°ë¥¼ JSON í˜•ì‹ìœ¼ë¡œ ë³€í™˜í•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\nì•ˆì „ ë©”ì»¤ë‹ˆì¦˜:\n- ì›ë³¸ ë°ì´í„° ë³´ì¡´\n- ê²€ì¦ í›„ ì ìš©\n- ì‹¤íŒ¨ ì‹œ ìë™ ë¡¤ë°±')) return;
            safeMigrate(false);
        }

        // ì•ˆì „ ë§ˆì´ê·¸ë ˆì´ì…˜ í…ŒìŠ¤íŠ¸ (ê°•ì œ ì‹¤íŒ¨ ì‹œë®¬ë ˆì´ì…˜)
        function testSafeMigrationRollback() {
            const output = document.getElementById('compression-output');
            const testKey = 'vocabmaster_test_migration';
            const testBackupKey = 'vocabmaster_test_migration_backup';
            const TEMP_SUFFIX = '_migration_temp';
            const results = [];

            results.push('=== ì•ˆì „ ë§ˆì´ê·¸ë ˆì´ì…˜ ë¡¤ë°± í…ŒìŠ¤íŠ¸ ===\n');

            // í…ŒìŠ¤íŠ¸ ë°ì´í„° ìƒì„±
            const testData = { word1: 'memorized', word2: 'learning', timestamp: Date.now() };
            const originalJson = JSON.stringify(testData);
            localStorage.setItem(testKey, originalJson);
            localStorage.setItem(testBackupKey, originalJson);
            results.push('1. í…ŒìŠ¤íŠ¸ ë°ì´í„° ìƒì„± (JSON í˜•ì‹)');
            results.push(`   ì›ë³¸: ${originalJson.substring(0, 50)}...`);

            // ì••ì¶• ì‹œë„ (ì„ì‹œ í‚¤ ì‚¬ìš©)
            const compressed = compress(testData);
            const tempKey = testKey + TEMP_SUFFIX;
            localStorage.setItem(tempKey, compressed);
            results.push('\n2. ì„ì‹œ í‚¤ì— ì••ì¶• ë°ì´í„° ì €ì¥');
            results.push(`   ì„ì‹œ: ${compressed.substring(0, 30)}...`);

            // ê²€ì¦ ì‹œë®¬ë ˆì´ì…˜ (ì˜ë„ì  ì‹¤íŒ¨)
            results.push('\n3. ê²€ì¦ ì‹¤íŒ¨ ì‹œë®¬ë ˆì´ì…˜...');
            const simulateFailure = true;

            if (simulateFailure) {
                results.push('   â†’ ê²€ì¦ ì‹¤íŒ¨! ë¡¤ë°± ì‹œì‘...');

                // ì„ì‹œ ë°ì´í„° ì‚­ì œ
                localStorage.removeItem(tempKey);
                results.push('   â†’ ì„ì‹œ ë°ì´í„° ì‚­ì œ');

                // ì›ë³¸ í™•ì¸
                const originalStillExists = localStorage.getItem(testKey) === originalJson;
                results.push(`   â†’ ì›ë³¸ ë°ì´í„° í™•ì¸: ${originalStillExists ? 'âœ… ë³´ì¡´ë¨' : 'âŒ ì†ìƒë¨'}`);
            }

            // ì •ë¦¬
            localStorage.removeItem(testKey);
            localStorage.removeItem(testBackupKey);
            localStorage.removeItem(tempKey);
            results.push('\n4. í…ŒìŠ¤íŠ¸ ë°ì´í„° ì •ë¦¬ ì™„ë£Œ');

            results.push('\nê²°ê³¼: âœ… ë¡¤ë°± ë©”ì»¤ë‹ˆì¦˜ ì •ìƒ ë™ì‘');
            results.push('      ì›ë³¸ ë°ì´í„°ëŠ” ê²€ì¦ ì‹¤íŒ¨ ì‹œì—ë„ ë³´ì¡´ë©ë‹ˆë‹¤.');

            output.textContent = results.join('\n');
            output.classList.remove('empty');
        }

        // ==================== ë°ì´í„° ì†ìƒ ====================

        function corruptData(key) {
            const current = localStorage.getItem(key);
            if (!current) {
                alert(`${key}ì— ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.`);
                return;
            }

            const corrupted = '{corrupted_' + Math.random().toString(36).substring(7) + ': "invalid json';
            localStorage.setItem(key, corrupted);

            alert(`${key} ë°ì´í„°ê°€ ì†ìƒë˜ì—ˆìŠµë‹ˆë‹¤.`);
            refreshStatus();
        }

        function corruptBoth(type) {
            let mainKey, backupKey;

            switch(type) {
                case 'progress':
                    mainKey = KEYS.PROGRESS;
                    backupKey = KEYS.PROGRESS_BACKUP;
                    break;
                case 'stats':
                    mainKey = KEYS.STATS;
                    backupKey = KEYS.STATS_BACKUP;
                    break;
                case 'categories':
                    mainKey = KEYS.CUSTOM_CATEGORIES;
                    backupKey = KEYS.CUSTOM_CATEGORIES_BACKUP;
                    break;
            }

            if (mainKey) corruptData(mainKey);
            if (backupKey) corruptData(backupKey);
        }

        function corruptAll() {
            if (!confirm('ì •ë§ë¡œ ëª¨ë“  ë°ì´í„°ë¥¼ ì†ìƒì‹œí‚¤ê² ìŠµë‹ˆê¹Œ?')) return;

            const keys = [
                KEYS.PROGRESS, KEYS.PROGRESS_BACKUP,
                KEYS.STATS, KEYS.STATS_BACKUP,
                KEYS.CUSTOM_CATEGORIES, KEYS.CUSTOM_CATEGORIES_BACKUP
            ];

            keys.forEach(key => {
                if (localStorage.getItem(key)) {
                    const corrupted = '{corrupted_all: "invalid';
                    localStorage.setItem(key, corrupted);
                }
            });

            alert('ëª¨ë“  ë°ì´í„°ê°€ ì†ìƒë˜ì—ˆìŠµë‹ˆë‹¤.');
            refreshStatus();
        }

        // ==================== ë³µêµ¬ í…ŒìŠ¤íŠ¸ ====================

        function testRecovery() {
            const output = document.getElementById('recovery-output');
            let results = [];

            results.push('=== ë³µêµ¬ ì‹œë®¬ë ˆì´ì…˜ ê²°ê³¼ ===\n');

            results.push('[ Progress ]');
            results.push(testRecoveryFor(KEYS.PROGRESS, KEYS.PROGRESS_BACKUP, KEYS.TEMP));

            results.push('\n[ Stats ]');
            results.push(testRecoveryFor(KEYS.STATS, KEYS.STATS_BACKUP, null));

            results.push('\n[ Custom Categories ]');
            results.push(testRecoveryFor(KEYS.CUSTOM_CATEGORIES, KEYS.CUSTOM_CATEGORIES_BACKUP, null));

            output.textContent = results.join('\n');
            output.classList.remove('empty');
        }

        function testRecoveryFor(mainKey, backupKey, tempKey) {
            const results = [];

            // Main í™•ì¸ (ìë™ í˜•ì‹ ê°ì§€)
            const mainRaw = localStorage.getItem(mainKey);
            let mainOk = false;
            if (mainRaw) {
                try {
                    const data = decompress(mainRaw);
                    if (data) {
                        mainOk = true;
                        const format = detectFormat(mainRaw);
                        results.push(`  Main: ì •ìƒ (${format}) -> Main ì‚¬ìš©`);
                    } else {
                        throw new Error();
                    }
                } catch (e) {
                    results.push('  Main: ì†ìƒë¨');
                }
            } else {
                results.push('  Main: ì—†ìŒ');
            }

            if (mainOk) return results.join('\n');

            // Backup í™•ì¸ (ìë™ í˜•ì‹ ê°ì§€)
            const backupRaw = localStorage.getItem(backupKey);
            let backupOk = false;
            if (backupRaw) {
                try {
                    const data = decompress(backupRaw);
                    if (data) {
                        backupOk = true;
                        const format = detectFormat(backupRaw);
                        results.push(`  Backup: ì •ìƒ (${format}) -> Backupì—ì„œ ë³µêµ¬`);
                    } else {
                        throw new Error();
                    }
                } catch (e) {
                    results.push('  Backup: ì†ìƒë¨');
                }
            } else {
                results.push('  Backup: ì—†ìŒ');
            }

            if (backupOk) return results.join('\n');

            // Temp í™•ì¸
            if (tempKey) {
                const tempRaw = sessionStorage.getItem(tempKey);
                if (tempRaw) {
                    try {
                        JSON.parse(tempRaw);
                        results.push('  Temp: ì •ìƒ -> Tempì—ì„œ ë³µêµ¬');
                        return results.join('\n');
                    } catch (e) {
                        results.push('  Temp: ì†ìƒë¨');
                    }
                } else {
                    results.push('  Temp: ì—†ìŒ');
                }
            }

            results.push('  ê²°ê³¼: ë³µêµ¬ ë¶ˆê°€ -> ì´ˆê¸°í™” ë˜ëŠ” ëª¨ë‹¬ í‘œì‹œ');
            return results.join('\n');
        }

        function reloadApp() {
            if (confirm('VocabMaster ì•±ì„ ìƒˆë¡œê³ ì¹¨í•˜ì—¬ ì‹¤ì œ ë³µêµ¬ ë©”ì»¤ë‹ˆì¦˜ì„ í…ŒìŠ¤íŠ¸í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                window.location.href = 'index.html';
            }
        }

        // ==================== Write-Verify í…ŒìŠ¤íŠ¸ ====================

        function testWriteVerify() {
            const output = document.getElementById('write-verify-output');
            const testKey = 'vocabmaster_test_write_verify';
            const results = [];

            results.push('=== ê¸°ë³¸ Write-Verify íŒ¨í„´ í…ŒìŠ¤íŠ¸ ===\n');

            const testData = { test: true, timestamp: Date.now(), value: 'test_' + Math.random() };

            // 1. ì“°ê¸°
            results.push('1. ë°ì´í„° ì“°ê¸° (JSON)...');
            try {
                localStorage.setItem(testKey, JSON.stringify(testData));
                results.push('   ì„±ê³µ: ë°ì´í„° ì €ì¥ë¨');
            } catch (e) {
                results.push('   ì‹¤íŒ¨: ' + e.message);
                output.textContent = results.join('\n');
                return;
            }

            // 2. ì½ê¸° + ê²€ì¦
            results.push('\n2. ë°ì´í„° ì½ê¸° ë° ê²€ì¦...');
            const readBack = localStorage.getItem(testKey);
            try {
                const parsed = JSON.parse(readBack);
                if (parsed.test === testData.test && parsed.timestamp === testData.timestamp) {
                    results.push('   ì„±ê³µ: ë°ì´í„° ë¬´ê²°ì„± í™•ì¸ë¨');
                } else {
                    results.push('   ì‹¤íŒ¨: ë°ì´í„° ë¶ˆì¼ì¹˜');
                }
            } catch (e) {
                results.push('   ì‹¤íŒ¨: íŒŒì‹± ì˜¤ë¥˜');
            }

            // ì •ë¦¬
            localStorage.removeItem(testKey);
            results.push('\n3. í…ŒìŠ¤íŠ¸ ë°ì´í„° ì •ë¦¬ ì™„ë£Œ');
            results.push('\nê²°ê³¼: âœ… Write-Verify íŒ¨í„´ ì •ìƒ ì‘ë™');

            output.textContent = results.join('\n');
            output.classList.remove('empty');
        }

        function testWriteVerifyCompressed() {
            const output = document.getElementById('write-verify-output');
            const testKey = 'vocabmaster_test_write_verify_lz';
            const results = [];

            results.push('=== ì••ì¶• Write-Verify íŒ¨í„´ í…ŒìŠ¤íŠ¸ ===\n');

            const testData = { test: true, timestamp: Date.now(), value: 'test_' + Math.random() };

            // 1. ì••ì¶• í›„ ì“°ê¸°
            results.push('1. ë°ì´í„° ì••ì¶• í›„ ì“°ê¸°...');
            const compressed = compress(testData);
            try {
                localStorage.setItem(testKey, compressed);
                results.push('   ì„±ê³µ: ì••ì¶• ë°ì´í„° ì €ì¥ë¨');
                results.push('   í˜•ì‹: ' + (compressed.startsWith('LZ:') ? 'LZ-String' : 'Unknown'));
            } catch (e) {
                results.push('   ì‹¤íŒ¨: ' + e.message);
                output.textContent = results.join('\n');
                return;
            }

            // 2. ì½ê¸° + í•´ì œ + ê²€ì¦
            results.push('\n2. ë°ì´í„° ì½ê¸°, í•´ì œ, ê²€ì¦...');
            const readBack = localStorage.getItem(testKey);
            try {
                const decompressed = decompress(readBack);
                if (decompressed && decompressed.test === testData.test && decompressed.timestamp === testData.timestamp) {
                    results.push('   ì„±ê³µ: ì••ì¶• í•´ì œ ë° ë¬´ê²°ì„± í™•ì¸ë¨');
                } else {
                    results.push('   ì‹¤íŒ¨: ë°ì´í„° ë¶ˆì¼ì¹˜');
                }
            } catch (e) {
                results.push('   ì‹¤íŒ¨: í•´ì œ ì˜¤ë¥˜ - ' + e.message);
            }

            // ì •ë¦¬
            localStorage.removeItem(testKey);
            results.push('\n3. í…ŒìŠ¤íŠ¸ ë°ì´í„° ì •ë¦¬ ì™„ë£Œ');
            results.push('\nê²°ê³¼: âœ… ì••ì¶• Write-Verify íŒ¨í„´ ì •ìƒ ì‘ë™');

            output.textContent = results.join('\n');
            output.classList.remove('empty');
        }

        // ==================== ë©€í‹°íƒ­ í…ŒìŠ¤íŠ¸ ====================

        function testReadModifyWrite() {
            const output = document.getElementById('multitab-output');
            const testKey = 'vocabmaster_test_rmw';
            const results = [];

            results.push('=== Read-Modify-Write íŒ¨í„´ í…ŒìŠ¤íŠ¸ ===\n');

            // ì´ˆê¸° ë°ì´í„° ì„¤ì •
            const initialData = { word1: 'learning', word2: 'new' };
            localStorage.setItem(testKey, JSON.stringify(initialData));
            results.push('1. ì´ˆê¸° ë°ì´í„° ì„¤ì •: ' + JSON.stringify(initialData));

            // ë‹¤ë¥¸ íƒ­ì—ì„œ ë³€ê²½ ì‹œë®¬ë ˆì´ì…˜
            const otherTabData = { word1: 'learning', word2: 'new', word3: 'memorized' };
            localStorage.setItem(testKey, JSON.stringify(otherTabData));
            results.push('2. ë‹¤ë¥¸ íƒ­ì—ì„œ word3 ì¶”ê°€: ' + JSON.stringify(otherTabData));

            // í˜„ì¬ íƒ­ì—ì„œ Read-Modify-Write
            results.push('\n3. Read-Modify-Write ì‹¤í–‰:');
            const latest = JSON.parse(localStorage.getItem(testKey));
            results.push('   Read: ' + JSON.stringify(latest));

            const myChange = { word1: 'memorized' };
            const merged = { ...latest, ...myChange };
            results.push('   Modify: word1 -> memorized');

            localStorage.setItem(testKey, JSON.stringify(merged));
            results.push('   Write: ' + JSON.stringify(merged));

            // ê²€ì¦
            const final = JSON.parse(localStorage.getItem(testKey));
            results.push('\n4. ìµœì¢… ê²°ê³¼: ' + JSON.stringify(final));

            const allPreserved = final.word1 === 'memorized' &&
                                 final.word2 === 'new' &&
                                 final.word3 === 'memorized';
            results.push('\nê²°ê³¼: ' + (allPreserved ? 'âœ… ëª¨ë“  ë³€ê²½ì‚¬í•­ ë³´ì¡´ë¨' : 'âŒ ë°ì´í„° ì†ì‹¤ ë°œìƒ'));

            localStorage.removeItem(testKey);

            output.textContent = results.join('\n');
            output.classList.remove('empty');
        }

        function testProgressMerge() {
            const output = document.getElementById('multitab-output');
            const results = [];

            results.push('=== Progress ë¨¸ì§€ í…ŒìŠ¤íŠ¸ (ë†’ì€ ìƒíƒœ ìœ ì§€) ===\n');

            const statusPriority = { 'new': 0, 'learning': 1, 'memorized': 2 };

            const tabAData = { word1: 'learning', word2: 'memorized', word3: 'new' };
            const tabBData = { word1: 'memorized', word2: 'learning', word3: 'learning' };

            results.push('Tab A ë°ì´í„°: ' + JSON.stringify(tabAData));
            results.push('Tab B ë°ì´í„°: ' + JSON.stringify(tabBData));
            results.push('\në¨¸ì§€ ë¡œì§: ê° ë‹¨ì–´ë³„ë¡œ ë” ë†’ì€ ìƒíƒœ ìœ ì§€\n');

            // ë¨¸ì§€ ì‹¤í–‰
            const merged = {};
            const allKeys = new Set([...Object.keys(tabAData), ...Object.keys(tabBData)]);
            allKeys.forEach(key => {
                const aStatus = tabAData[key] || 'new';
                const bStatus = tabBData[key] || 'new';
                const aPriority = statusPriority[aStatus] || 0;
                const bPriority = statusPriority[bStatus] || 0;
                merged[key] = bPriority > aPriority ? bStatus : aStatus;
            });

            results.push('ë¨¸ì§€ ê²°ê³¼:');
            results.push(`  word1: A=${tabAData.word1}, B=${tabBData.word1} -> ${merged.word1}`);
            results.push(`  word2: A=${tabAData.word2}, B=${tabBData.word2} -> ${merged.word2}`);
            results.push(`  word3: A=${tabAData.word3}, B=${tabBData.word3} -> ${merged.word3}`);

            const correct = merged.word1 === 'memorized' &&
                           merged.word2 === 'memorized' &&
                           merged.word3 === 'learning';
            results.push('\nê²°ê³¼: ' + (correct ? 'âœ… ë†’ì€ ìƒíƒœê°€ ìœ ì§€ë¨' : 'âŒ ë¨¸ì§€ ì˜¤ë¥˜'));

            output.textContent = results.join('\n');
            output.classList.remove('empty');
        }

        function simulateOtherTabChange() {
            const output = document.getElementById('multitab-output');

            // Storage ì´ë²¤íŠ¸ ë°œìƒ (ê°™ì€ íƒ­ì—ì„œëŠ” ë°œìƒí•˜ì§€ ì•Šìœ¼ë¯€ë¡œ ì‹œë®¬ë ˆì´ì…˜)
            const testData = { simulated: true, time: new Date().toLocaleTimeString() };
            const key = 'vocabmaster_test_event';

            localStorage.setItem(key, JSON.stringify(testData));

            output.textContent = '=== ë‹¤ë¥¸ íƒ­ ë³€ê²½ ì‹œë®¬ë ˆì´ì…˜ ===\n\n' +
                'ìƒˆ ì°½/íƒ­ì—ì„œ VocabMasterë¥¼ ì—´ê³  ë‹¨ì–´ ìƒíƒœë¥¼ ë³€ê²½í•˜ë©´,\n' +
                'ì´ íƒ­ì—ì„œ Storage ì´ë²¤íŠ¸ë¥¼ í†µí•´ ìë™ìœ¼ë¡œ ê°ì§€ë©ë‹ˆë‹¤.\n\n' +
                'í…ŒìŠ¤íŠ¸ ë°©ë²•:\n' +
                '1. ìƒˆ íƒ­ì—ì„œ index.html ì—´ê¸°\n' +
                '2. ë‹¨ì–´ í•™ìŠµ ìƒíƒœ ë³€ê²½\n' +
                '3. ì´ íƒ­ì—ì„œ "ìƒíƒœ ìƒˆë¡œê³ ì¹¨" í´ë¦­í•˜ì—¬ ë™ê¸°í™” í™•ì¸\n\n' +
                'ì°¸ê³ : storage ì´ë²¤íŠ¸ëŠ” ê°™ì€ íƒ­ì—ì„œëŠ” ë°œìƒí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.';
            output.classList.remove('empty');

            localStorage.removeItem(key);
        }

        // ==================== ë°ì´í„° ì´ˆê¸°í™” ====================

        function clearBackups() {
            if (!confirm('ëª¨ë“  ë°±ì—… ë°ì´í„°ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) return;

            localStorage.removeItem(KEYS.PROGRESS_BACKUP);
            localStorage.removeItem(KEYS.STATS_BACKUP);
            localStorage.removeItem(KEYS.CUSTOM_CATEGORIES_BACKUP);

            alert('ë°±ì—… ë°ì´í„°ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.');
            refreshStatus();
        }

        function clearTemp() {
            sessionStorage.removeItem(KEYS.TEMP);
            alert('Session Tempê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.');
            refreshStatus();
        }

        // ==================== í…ŒìŠ¤íŠ¸ ë°ì´í„° ìƒì„± ====================

        function randomString(length) {
            const chars = 'abcdefghijklmnopqrstuvwxyz';
            let result = '';
            for (let i = 0; i < length; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result;
        }

        function randomPronunciation() {
            const vowels = ['ae', 'a', 'o', 'e', 'i', 'u'];
            const consonants = ['b', 'd', 'f', 'g', 'h', 'k', 'l', 'm', 'n', 'p', 'r', 's', 't', 'v', 'w', 'z'];
            let result = '';
            const syllables = Math.floor(Math.random() * 3) + 1;
            for (let i = 0; i < syllables; i++) {
                result += consonants[Math.floor(Math.random() * consonants.length)];
                result += vowels[Math.floor(Math.random() * vowels.length)];
            }
            return result;
        }

        function generateAndDownloadJSON() {
            const WORD_COUNT = 10000;
            const partsOfSpeech = ['noun', 'verb', 'adj', 'adv', 'prep'];
            const prefixes = ['test', 'sample', 'demo', 'mock', 'dummy'];
            const suffixes = ['word', 'data', 'item', 'value', 'text'];

            const words = [];
            for (let i = 0; i < WORD_COUNT; i++) {
                const wordLength = Math.floor(Math.random() * 8) + 3;
                const word = `test_${randomString(wordLength)}_${i + 1}`;
                const hasMultipleMeanings = Math.random() > 0.7;
                const meaningCount = hasMultipleMeanings ? Math.floor(Math.random() * 3) + 2 : 1;

                const meanings = [];
                for (let j = 0; j < meaningCount; j++) {
                    const prefix = prefixes[Math.floor(Math.random() * prefixes.length)];
                    const suffix = suffixes[Math.floor(Math.random() * suffixes.length)];
                    meanings.push({
                        partOfSpeech: partsOfSpeech[Math.floor(Math.random() * partsOfSpeech.length)],
                        meaning: `${prefix} ${suffix} ${Math.floor(Math.random() * 1000)}`,
                        examples: [{
                            sentence: `This is a test sentence for ${word}.`,
                            translation: `This is translation for ${word}.`
                        }]
                    });
                }

                words.push({
                    word: word,
                    pronunciation: randomPronunciation(),
                    meanings: meanings
                });
            }

            const blob = new Blob([JSON.stringify(words, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'test-10000-words.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function generateAndDownloadCSV() {
            const WORD_COUNT = 10000;
            const partsOfSpeech = ['noun', 'verb', 'adj', 'adv', 'prep'];
            const prefixes = ['test', 'sample', 'demo', 'mock', 'dummy'];
            const suffixes = ['word', 'data', 'item', 'value', 'text'];

            const lines = ['word,pronunciation,partOfSpeech,meaning,example,translation'];
            for (let i = 0; i < WORD_COUNT; i++) {
                const wordLength = Math.floor(Math.random() * 8) + 3;
                const word = `csv_${randomString(wordLength)}_${i + 1}`;
                const pronunciation = randomPronunciation();
                const partOfSpeech = partsOfSpeech[Math.floor(Math.random() * partsOfSpeech.length)];
                const prefix = prefixes[Math.floor(Math.random() * prefixes.length)];
                const suffix = suffixes[Math.floor(Math.random() * suffixes.length)];
                const meaning = `${prefix} ${suffix} ${Math.floor(Math.random() * 1000)}`;
                const example = `This is a CSV test for ${word}.`;
                const translation = `This is CSV translation for ${word}.`;

                lines.push(`${word},${pronunciation},${partOfSpeech},${meaning},"${example}","${translation}"`);
            }

            const blob = new Blob([lines.join('\n')], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'test-10000-words.csv';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function clearAllData() {
            if (!confirm('ì •ë§ë¡œ ëª¨ë“  VocabMaster ë°ì´í„°ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\nì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!')) return;

            Object.values(KEYS).forEach(key => {
                localStorage.removeItem(key);
            });
            sessionStorage.removeItem(KEYS.TEMP);

            localStorage.removeItem('vocabmaster_disabled_categories');
            localStorage.removeItem('vocabmaster_backup_info');

            alert('ëª¨ë“  ë°ì´í„°ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.');
            refreshStatus();
        }
    </script>
</body>
</html>
